<?php
// $Id$
/**
 * @file
 * Version Control API - An interface to version control systems
 * whose functionality is provided by pluggable back-end modules.
 *
 * Copyright 2007 by Jakob Petsovits (http://drupal.org/user/56020)
 */

// Optional capabilities that backend modules can provide.
define('VERSIONCONTROL_CAPABILITY_CREATE_REPOSITORY',       0);
define('VERSIONCONTROL_CAPABILITY_ACCOUNT_MANAGEMENT',      1);
define('VERSIONCONTROL_CAPABILITY_DIRECTORY_RESTRICTIONS',  2);
define('VERSIONCONTROL_CAPABILITY_BRANCH_TAG_RESTRICTIONS', 3);
define('VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS',          4);
define('VERSIONCONTROL_CAPABILITY_LIST_FILES',              5);

// VCS item types.
define('VERSIONCONTROL_ITEM_FILE',            0);
define('VERSIONCONTROL_ITEM_DIRECTORY',       1);
// This one is only used for item listings in version control systems that
// don't support atomic commits. That is, for CVS only.
define('VERSIONCONTROL_ITEM_FILE_DELETED',    2);

// VCS file types.
define('VERSIONCONTROL_FILE_TEXT',            0);
define('VERSIONCONTROL_FILE_BINARY',          1);

// VCS actions for a single item (file or directory) in a commit.
define('VERSIONCONTROL_ACTION_ADDED',         0);
define('VERSIONCONTROL_ACTION_MODIFIED',      1);
define('VERSIONCONTROL_ACTION_MOVED',         2);
define('VERSIONCONTROL_ACTION_COPIED',        3);
define('VERSIONCONTROL_ACTION_MERGED',        4);
define('VERSIONCONTROL_ACTION_DELETED',       5);

// Flags that backends can set to specify if Version Control API should do
// work for them.
define('VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES', 0);
define('VERSIONCONTROL_FLAG_AUTOADD_COMMITS',      1);

// The backend-only part of the API.
include_once(drupal_get_path('module', 'versioncontrol') .'/versioncontrol-backend.inc');

/**
 * Get a list of all backends and more detailed information about each of them.
 *
 * @return
 *   A structured array containing information about all known backends.
 *   Array keys are the unique string identifier of the version control system.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'name': The user-visible name of the VCS.
 *   'description': A short description of the backend, if possible not longer
 *                  than one or two sentences.
 *   'capabilities': An array listing optional capabilities, in addition to the
 *                   required functionality like retrieval of detailed
 *                   commit information. Array values can be an arbitrary
 *                   combination of VERSIONCONTROL_CAPABILITY_* values. If no
 *                   additional capabilities are supported by the backend,
 *                   this array will be empty.
 *
 *   If no single backends can be found, an empty array is returned.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_backends() {
  static $backends;

  if (!isset($backends)) {
    $backends = module_invoke_all('versioncontrol_backends');
  }
  return $backends;
}

/**
 * Determine if a given backend module implements a specific backend function.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 *
 * @return
 *   TRUE if the backend implements the function, or FALSE otherwise.
 */
function versioncontrol_backend_implements($vcs, $function) {
  if (function_exists('versioncontrol_'. $vcs .'_'. $function)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Call a function from the desired VCS backend and return its result value.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 * @param $args
 *   An array of argument that will be passed to the backend function.
 *
 * @return
 *   Returns the result of the backend function. The result value of calls
 *   where the backend function has no implementation is undefined, as functions
 *   called by this function are considered mandatory for the backend.
 */
function _versioncontrol_call_backend($vcs, $function, $args) {
  return call_user_func_array('versioncontrol_'. $vcs .'_'. $function, $args);
}


/**
 * Retrieve a set of repositories if they match the given constraints.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements are:
 *
 *   'vcs': An array of strings, like array('cvs', 'svn', 'git').
 *          If given, only commits for these backends will be returned.
 *   'repo_ids': An array of repository ids.
 *               If given, only the corresponding repositories will be returned.
 *
 * @return
 *   An array of repositories where the key of each element is the
 *   repository id. The corresponding value contains a structured array
 *   with the following keys:
 *
 *   'repo_id': The unique repository id.
 *   'name': The user-visible name of the repository.
 *   'vcs': The unique string identifier of the version control system
 *          that powers this repository.
 *   'root': The root directory of the repository. In most cases,
 *           this will be a local directory (e.g. '/var/repos/drupal'),
 *           but it may also be some specialized string for remote repository
 *           access. How this string may look like depends on the backend.
 *   '[xxx]_specific': An array of VCS specific additional repository
 *                     information. How this array looks like is defined by the
 *                     corresponding backend module (versioncontrol_[xxx]).
 *   'url_commit_view', 'url_item_view', 'url_diff' and 'url_tracker':
 *      Not meant to be used directly, please refer to the
 *      versioncontrol_get_url_commit_view(), versioncontrol_get_url_item_view(),
 *      versioncontrol_get_url_diff() and versioncontrol_get_url_tracker()
 *      functions if you need this functionality.
 *
 *   If no single repository matches these constraints,
 *   an empty array is returned.
 */
function versioncontrol_get_repositories($constraints = array()) {
  $and_constraints = array();
  $params = array();

  if (isset($constraints['vcs'])) {
    $or_constraints = array();
    foreach ($constraints['vcs'] as $vcs) {
      $or_constraints[] = "vcs = '%s'";
      $params[] = $vcs;
    }
    $and_constraints[] = '('. implode(" OR ", $or_constraints) .')';
  }

  if (isset($constraints['repo_ids'])) {
    $or_constraints = array();
    foreach ($constraints['repo_ids'] as $repo_id) {
      $or_constraints[] = "repo_id = '%d'";
      $params[] = $repo_id;
    }
    $and_constraints[] = '('. implode(' OR ', $or_constraints) .')';
  }

  // All constraints have been gathered, execute the query now.
  if (empty($and_constraints)) {
    $result = db_query('SELECT * FROM {versioncontrol_repositories}');
  }
  else {
    $result = db_query('SELECT * FROM {versioncontrol_repositories}
                        WHERE '. implode(' AND ', $and_constraints), $params);
  }

  // Sort the retrieved repositories by backend.
  $backends = versioncontrol_get_backends();
  $repositories_by_backend = array();

  while ($repository = db_fetch_array($result)) {
    if (!isset($backends[$repository['vcs']])) {
      // don't include repositories for which no backend module exists
      continue;
    }
    if (!isset($repositories_by_backend[$repository['vcs']])) {
      $repositories_by_backend[$repository['vcs']] = array();
    }
    $repository[$repository['vcs'] .'_specific'] = array();
    $repositories_by_backend[$repository['vcs']][$repository['repo_id']] = $repository;
  }

  $result_repositories = array();

  // Fetch VCS specific repository data additions, either by ourselves (if the
  // VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES flag has been set by the backend)
  // or by calling [vcs_backend]_alter_repositories().
  foreach ($repositories_by_backend as $vcs => $vcs_repositories) {
    $is_autoadd = in_array(VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES,
                           $backends[$vcs]['flags']);

    if ($is_autoadd) {
      $repo_ids = array();
      foreach ($vcs_repositories as $repo_id => $repository) {
        $repo_ids[] = $repo_id;
      }
      $additions = _versioncontrol_db_get_additions(
        'versioncontrol_'. $vcs .'_repositories', 'repo_id', $repo_ids
      );

      foreach ($additions as $repo_id => $additions) {
        if (isset($vcs_repositories[$repo_id])) {
          $vcs_repositories[$repo_id][$vcs .'_specific'] = $additions;
        }
      }
    }

    // Provide an opportunity for the backend to add its own stuff.
    if (versioncontrol_backend_implements($vcs, 'alter_repositories')) {
      _versioncontrol_call_backend(
        $vcs, 'alter_repositories', array($vcs_repositories)
      );
    }

    foreach ($vcs_repositories as $repository) {
      $result_repositories[$repository['repo_id']] = $repository;
    }
  }

  return $result_repositories;
}


/**
 * Retrieve a set of commits for the specified repository if they match
 * the given constraints.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements are:
 *
 *   'vcs': An array of strings, like array('cvs', 'svn', 'git').
 *          If given, only commits for these backends will be returned.
 *   'repo_ids': An array of repository ids. If given, only commits
 *               for the corresponding repositories will be returned.
 *   'branches': An array of strings, specified separately for each repository,
 *               like array($repo_id => array('HEAD', 'DRUPAL-5')).
 *               If given, only commits on the given branches will be returned.
 *   'paths': An array of strings (item locations), specified separately
 *            for each repository, like
 *              array($repo_id => array(
 *                '/trunk/contributions/modules/versioncontrol',
 *                '/trunk/contributions/themes/b2',
 *              )).
 *            If given, only commits that affected this item (or its children,
 *            in case the item is a directory) will be returned.
 *   'commit_id_lower': A commit id. If given, the result set will not contain
 *                      commits earlier than this lower bound. Mind that
 *                      commit ids only correspond to chronological order
 *                      within the bounds of each repository.
 *   'commit_id_upper': A commit id. If given, the result set will not contain
 *                      commits later than this upper bound. Mind that
 *                      commit ids only correspond to chronological order
 *                      within the bounds of each repository.
 *   'date_lower': A Unix timestamp. If given, the result set will not contain
 *                 commits earlier than this lower bound.
 *   'date_upper': A Unix timestamp. If given, the result set will not contain
 *                 commits later than this upper bound.
 *   'uids': An array of Drupal user ids. If given, the result set will only
 *           contain commits that correspond to any of the specified users.
 *   'usernames': An array of system-specific usernames (the ones that the
 *                version control systems themselves get to see).
 *                Specified separately for each repository, like
 *                array($repo_id => array('dww', 'jpetso')).
 *                If given, the result set will only contain commits that
 *                correspond to any of the specified users.
 *   '[xxx]_specific': An array of VCS specific constraints. How this array
 *                     looks like is defined by the corresponding backend
 *                     module (versioncontrol_[xxx]). Other backend modules
 *                     won't get to see this constraint, so in theory you can
 *                     provide one of those for each backend in one
 *                     single query.
 *
 * @return
 *   An array of commits, reversely sorted by the time of the commit.
 *   Each element contains a structured array with the following keys:
 *
 *   'commit_id': The Drupal-specific commit identifier (a simple integer)
 *                which is unique among all commits in all repositories.
 *   'repository': The repository where this commit occurred.
 *                 This is a structured array, like a single element of
 *                 what is returned by versioncontrol_get_repositories().
 *   'date': The time when the revision was committed, given as Unix timestamp.
 *   'uid': The Drupal user id of the committer.
 *   'username': The system specific VCS username of the committer.
 *   'directory': The deepest-level directory in the repository that is common
 *                to all the changed items, e.g. '/src' if the commit changed
 *                the files '/src/subdir/code.php' and '/src/README.txt'.
 *   'message': The commit message.
 *   'revision': The VCS specific repository-wide revision identifier,
 *               like NULL in CVS, '27491' in Subversion or some SHA-1 key
 *               in various distributed version control systems.
 *   '[xxx]_specific': An array of VCS specific additional commit information.
 *                     How this array looks like is defined by the
 *                     corresponding backend module (versioncontrol_[xxx]).
 *
 *   If no single commit matches these constraints, an empty array is returned.
 */
function versioncontrol_get_commits($constraints = array()) {
}


/**
 * Retrieve a Drupal uid / VCS username mapping given a set of user ids.
 * Non-existing uids are discarded and don't appear in the result value.
 *
 * @param $uid_list
 *   An array containing Drupal user ids.
 * @param $repositories
 *   An array of structured arrays containing repository information,
 *   presumably a subset of what is returned by versioncontrol_get_repositories().
 *   If given, only usernames of this specific repository will be retrieved.
 *   If NULL, usernames of all repositories will be looked up.
 *
 * @return
 *   A structured array that looks like
 *   array(
 *     $drupal_uid => array(
 *       $repo_id => 'VCS username',
 *       ...
 *     ),
 *     ...
 *   ).
 *   If no system specific VCS usernames correlate to the given uids,
 *   an empty array is returned.
 */
function versioncontrol_get_authors_by_uid($uid_list, $repositories = NULL) {
  if (!isset($repositories)) {
    $repositories = versioncontrol_get_repositories(); // all of them.
  }

  $backends = array();
  foreach ($repositories as $repository) {
    if (!isset($backends[$repository['vcs']])) {
      $backends[$repository['vcs']] = array();
    }
    $backends[$repository['vcs']][] = $repository;
  }

  $authors = array();
  foreach ($backends as $vcs => $vcs_repositories) {
    $authors = array_merge_recursive($authors, _versioncontrol_call_backend(
      $vcs, 'get_authors_by_uid', array($uid_list, $vcs_repositories)
    ));
  }
  return $authors;
}

/**
 * Retrieve a Drupal uid / VCS username mapping given a set of usernames.
 * Non-existing usernames are discarded and don't appear in the result value.
 *
 * @param $usernames_by_repository
 *   An array containing system specific VCS usernames. Specified separately
 *   for each repository, like array($repo_id => array('dww', 'jpetso'), ...).
 * @param $cached_repositories
 *   If you already have loaded some or all of the repository arrays that
 *   correspond to the given repo_id keys, you can pass it here in order to
 *   save a database query. If not, this function will retrieve them for you.
 *   If you do pass a list of repository arrays, its format has to be
 *   array($repo_id => $repository, ...).
 *
 * @return
 *   A structured array that looks like
 *   array($drupal_uid => array($repo_id => 'VCS username', ...), ...).
 *   If no Drupal uids correlate to the given usernames,
 *   an empty array is returned.
 */
function versioncontrol_get_authors_by_username($usernames_by_repository, $cached_repositories = array()) {
  $repos = $cached_repositories;
  $missing_repo_ids = array();

  // Fetch the full repository arrays for the list of repo ids.
  // We need those to figure out the responsible VCS backends.
  foreach ($usernames_by_repository as $repo_id => $username_list) {
    if (!isset($repos[$repo_id])) {
      $missing_repo_ids[] = $repo_id;
    }
  }
  if (!empty($missing_repo_ids)) {
    $repos = array_merge($repos, versioncontrol_get_repositories(array(
      'repo_ids' => $missing_repo_ids,
    )));
  }

  // Ok, we got the repositories, now let's split them up among backends.
  $backends = array();
  foreach ($repos as $repo_id => $repository) {
    if (!isset($usernames_by_repository[$repo_id])) {
      continue;
    }
    if (!isset($backends[$repository['vcs']])) {
      $backends[$repository['vcs']] = array();
    }
    $backends[$repository['vcs']][$repo_id] = $usernames_by_repository[$repo_id];
  }

  // Now it's up to the backends to retrieve the results:
  $authors = array();
  foreach ($backends as $vcs => $vcs_usernames_by_repository) {
    $authors = array_merge_recursive($authors, _versioncontrol_call_backend(
      $vcs, 'get_authors_by_username',
      array($vcs_usernames_by_repository, $repos)
    ));
  }
  return $authors;
}


/**
 * Retrieve the URL of the repository viewer that displays the given commit
 * in the corresponding repository.
 *
 * @param $commit
 *   The commit whose view URL should be retrieved.
 *
 * @return
 *   The commit view URL corresponding to the given arguments.
 *   An empty string is returned if no commit view URL has been defined,
 *   or if the commit cannot be viewed for any reason.
 */
function versioncontrol_get_url_commit_view($commit) {
}

/**
 * Retrieve the URL of the repository viewer that displays the given item
 * in the corresponding repository.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose view URL should be retrieved.
 *
 * @return
 *   The item view URL corresponding to the given arguments.
 *   An empty string is returned if no item view URL has been defined,
 *   or if the item cannot be viewed for any reason.
 */
function versioncontrol_get_url_item_view($repository, $item) {
}

/**
 * Retrieve the URL of the repository viewer that displays the diff between
 * two given files in the corresponding repository.
 *
 * @param $repository
 *   A structured array containing repository information, like a single
 *   element of what versioncontrol_get_repositories() returns.
 * @param $file_item_new
 *   The new version of the file that should be diffed.
 * @param $file_item_old
 *   The old version of the file that should be diffed.
 *
 * @return
 *   The diff URL corresponding to the given arguments.
 *   An empty string is returned if no diff URL has been defined,
 *   or if the two items cannot be diffed for any reason.
 */
function versioncontrol_get_url_diff($repository, $file_item_new, $file_item_old) {
}

/**
 * Retrieve the URL of the issue tracker that displays the issue/case/bug page
 * of an issue id which presumably has been mentioned in a commit message.
 * As issue tracker urls are specific to each repository, this also needs
 * to be given as argument.
 *
 * @param $repository
 *   A structured array containing repository information, like a single
 *   element of what versioncontrol_get_repositories() returns.
 * @param $issue_id
 *   A number that uniquely identifies the mentioned issue/case/bug.
 *
 * @return
 *   The issue tracker URL corresponding to the given arguments.
 *   An empty string is returned if no issue tracker URL has been defined.
 */
function versioncontrol_get_url_tracker($repository, $issue_id) {
}


/**
 * Retrieves detailed information about what happened in a single commit.
 *
 * @param $commit
 *   The commit whose actions should be retrieved.
 *
 * @return
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. Array keys are the current/new paths, also for
 *   VERSIONCONTROL_ACTION_DELETED actions even if the file actually doesn't
 *   exist anymore. The corresponding array values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 *   'current item': The updated state of the modified item. Exists for all
 *                   actions except VERSIONCONTROL_ACTION_DELETED.
 *   'source items': An array with the previous state(s) of the modified item.
 *                   Path and branch will always be the same as in the current
 *                   item except for the VERSIONCONTROL_ACTION_MOVED,
 *                   VERSIONCONTROL_ACTION_COPIED and
 *                   VERSIONCONTROL_ACTION_MERGED actions.
 *                   Exists for all actions except VERSIONCONTROL_ACTION_ADDED.
 *
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   'internal': May be set by the backend to remember additional item info.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_commit_actions($commit) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_commit_actions', array($commit)
  );
}

/**
 * Retrieve the branches that have been affected by the given commit.
 *
 * @return
 *   An array of strings that identify a branch in the respective repository,
 *   like for example array('DRUPAL-5') or array('trunk', '5.x').
 */
function versioncontrol_get_commit_branches($commit) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_commit_branches', array($commit)
  );
}


/**
 * Retrieve all branches that exist for the given item $path, and how this item
 * is named there. The main branch ('HEAD', 'trunk', 'master' or however it is
 * called in the respective VCS) is also included in the result.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose set of branches should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $branch1_name => $branch1_item,
 *       $branch2_name => $branch2_item,
 *       ...
 *     ).
 *
 *   The corresponding item values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was last changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   'internal': May be set by the backend to remember additional item info.
 *
 *   An empty array is returned if there are no branches for this item.
 *   NULL is returned if the given item is not inside the repository at the
 *   time of 'revision'.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_item_branches($repository, $item) {
  return _versioncontrol_call_backend(
    $repository['vcs'], 'get_item_branches', array($repository, $item)
  );
}

/**
 * Retrieve all tags that exist for the given item $path, and how this item
 * is named there.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose history should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $tag1_name => $tag1_item,
 *       $tag2_name => $tag2_item,
 *       ...
 *     ).
 *
 *   The corresponding item values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was last changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   'internal': May be set by the backend to remember additional item info.
 *
 *   An empty array is returned if there are no tags for this item.
 *   NULL is returned if the given item is not inside the repository at the
 *   time of 'revision'.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_item_tags($repository, $item) {
  return _versioncontrol_call_backend(
    $repository['vcs'], 'get_item_tags', array($repository, $item)
  );
}

/**
 * Retrieve the revisions where the given item has been changed,
 * in reverse chronological order.
 *
 * Only direct descendants or predecessors of this item will be retrieved.
 * That means that history of the same item in a different (parallel) branch
 * will not be returned, except if the given state of the item was moved/copied
 * from there or goes back there in a more recent revision. In short, you'll
 * not get "1.7" and "1.2.2.4" items side by side if it doesn't make sense.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose history should be retrieved.
 *
 * @return
 *   An array containing the exact details of all item changes. Each element
 *   of the array is a structured array consisting of elements with the
 *   following keys:
 *
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 *   'current item': The updated state of the modified item. Exists for all
 *                   actions except VERSIONCONTROL_ACTION_DELETED.
 *   'source items': An array with the previous state(s) of the modified item.
 *                   Path and branch will always be the same as in the current
 *                   item except for the VERSIONCONTROL_ACTION_MOVED,
 *                   VERSIONCONTROL_ACTION_COPIED and
 *                   VERSIONCONTROL_ACTION_MERGED actions.
 *                   Exists for all actions except VERSIONCONTROL_ACTION_ADDED.
 *
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   'internal': May be set by the backend to remember additional item info.
 *
 *   NULL is returned if the given item is not under version control,
 *   or was not under version control at the time of the given revision.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_item_history($repository, $item) {
  return _versioncontrol_call_backend(
    $repository['vcs'], 'get_item_history', array($repository, $item)
  );
}


/**
 * Retrieve the set of files and directories that exist at a specified revision
 * in the given directory inside the repository.
 *
 * @param $repository
 *   The repository that the directory item is located in.
 * @param $directory_item
 *   The parent item of the the items that should be listed.
 * @param $recursive
 *   If FALSE, only the direct children of $path will be retrieved.
 *   If TRUE, you'll get every single descendant of $path.
 *
 * @return
 *   A structured item array containing the exact details of which items have
 *   been inside the directory at the time of the commit, including the
 *   directory itself. Array keys are the current/new paths.
 *   The corresponding item values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was last changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   'internal': May be set by the backend to remember additional item info.
 *
 *   NULL is returned if the given item is not inside the repository,
 *   or if it is not a directory item at all.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_directory_contents($repository, $directory_item, $recursive = FALSE) {
  if ($directory_item['type'] != VERSIONCONTROL_ITEM_DIRECTORY) {
    return NULL;
  }
  return _versioncontrol_call_backend(
    $repository['vcs'], 'get_directory_contents',
    array($repository, $directory_item, $recursive)
  );
}


/**
 * Retrieve the text or binary data of the given file in the specified commit.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_file_contents')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the file item is located in.
 * @param $file_item
 *   The file item whose contents should be retrieved.
 *
 * @return
 *   A structured array that consists of elements with the following keys:
 *
 *   'file type': Specifies the file type, which is either
 *                VERSIONCONTROL_FILE_TEXT or VERSIONCONTROL_FILE_BINARY.
 *   'contents': The raw contents of the file.
 *
 *   NULL is returned if the given item is not under version control,
 *   or was not under version control at the time of the given revision,
 *   or if it is not a file item at all.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_file_contents($repository, $file_item) {
  if (!($file_item['type'] == VERSIONCONTROL_ITEM_FILE
        || $file_item['type'] == VERSIONCONTROL_ITEM_FILE_DELETED)) {
    return NULL;
  }
  return _versioncontrol_call_backend_optional(
    $repository['vcs'], 'get_file_contents', array($repository, $file_item)
  );
}

/**
 * Retrieve an array where each element represents a single line of the
 * given file in the specified commit, annotated with the committer who last
 * modified that line. Note that annotations are generally a quite slow
 * operation, so expect this function to take a bit more time as well.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_file_annotation')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the file item is located in.
 * @param $file_item
 *   The file item whose annotation should be retrieved.
 *
 * @return
 *   A structured array that consists of one element per line, with
 *   line numbers as keys (starting from 1) and a structured array as values,
 *   where each of them consists of elements with the following keys:
 *
 *   'username': The system specific VCS username of the last committer.
 *   'line': The contents of the line, without linebreak characters.
 *
 *   NULL is returned if the given item is not under version control,
 *   or was not under version control at the time of the given revision,
 *   or if it is not a file item at all, or if it is marked as binary file, or
 *   if the specific backend module does not implement retrieving annotations.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_file_annotation($repository, $file_item) {
  if (!($file_item['type'] == VERSIONCONTROL_ITEM_FILE
        || $file_item['type'] == VERSIONCONTROL_ITEM_FILE_DELETED)) {
    return NULL;
  }
  return _versioncontrol_call_backend(
    $repository['vcs'], 'get_file_annotation', array($repository, $file_item)
  );
}

/**
 * Retrieve the deepest-level directory in the repository that is common
 * to all the changed items, e.g. '/src' if the commit changed the files
 * '/src/subdir/code.php' and '/src/README.txt', or '/' if the commit
 * changed the file '/src/README.txt' and the directory '/doc'.
 *
 * @param $commit_actions
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. The structure of this array is the same as
 *   the return value of versioncontrol_get_commit_actions().
 *
 * @return
 *   The common directory path of all items in the $commit_actions array,
 *   as mentioned above.
 */
function _versioncontrol_get_common_directory($commit_actions) {
  $paths = array();

  // gather the paths of all current and source items
  foreach ($commit_actions as $path => $action) {
    if (isset($action['current item'])) {
      $paths[] = $action['current item']['path'];
    }
    // Items that were only modified have the same path, don't get it twice.
    if ($action['type'] != VERSIONCONTROL_ACTION_MODIFIED && isset($action['source items'])) {
      foreach($action['source items'] as $item) {
        $paths[] = $item['path'];
      }
    }
  }
  if (empty($paths)) {
    return '/';
  }

  $dirparts = explode('/', dirname(array_pop($paths)));

  foreach ($paths as $path) {
    $new_dirparts = array();
    $current_dirparts = explode('/', dirname($path));
    $mincount = min(count($dirparts), count($current_dirparts));

    for ($i = 0; $i < $mincount; $i++) {
      if ($dirparts[$i] == $current_dirparts[$i]) {
        $new_dirparts[] = $dirparts[$i];
      }
    }
    $dirparts = $new_dirparts;
  }

  return implode('/', $dirparts);
}


/**
 * Generate and execute an INSERT query for the given table based on key names,
 * values and types of the given array elements. This function basically
 * accomplishes the insertion part of Version Control API's 'autoadd' feature.
 */
function _versioncontrol_db_insert_additions($table_name, $elements) {
  $keys = array();
  $values = array();
  $types = array();

  foreach ($elements as $key => $value) {
    $keys[] = $key;
    $values[] = $value;
    $types[] = is_numeric($value) ? "'%d'" : "'%s'";
  }

  db_query(
    'INSERT INTO {'. $table_name .'} ('. implode(', ', $keys) .')
     VALUES ('. implode(', ', $types) .')', $values
  );
}

/**
 * Generate and execute a SELECT query for the given table base on the name
 * and given values of this table's primary key. This function basically
 * accomplishes the retrieval part of Version Control API's 'autoadd' feature.
 * In order to avoid unnecessary complexity, the primary key may not consist
 * of multiple columns and has to be a numeric value.
 */
function _versioncontrol_db_get_additions($table_name, $primary_key_name, $keys) {
  $or_constraints = array();

  foreach ($keys as $key) {
    $or_constraints[] = $primary_key_name ." = '%d'";
  }

  $result = db_query('SELECT * FROM {'. $table_name .'}
                      WHERE '. implode(' OR ', $or_constraints), $keys);

  $additions = array();
  while ($addition = db_fetch_array($result)) {
    $key = $addition[$primary_key_name];
    unset($addition[$primary_key_name]);
    $additions[$key] = $addition;
  }
  return $additions;
}
