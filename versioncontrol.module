<?php
// $Id$
/**
 * @file
 * Version Control API - An interface to version control systems
 * whose functionality is provided by pluggable back-end modules.
 *
 * Copyright 2007 by Jakob Petsovits <jpetso@gmx.at>
 *
 * Distributed under the GNU General Public Licence version 2 or higher,
 * as published by the FSF on http://www.gnu.org/copyleft/gpl.html
 */

// Optional capabilities that backend modules can provide.
define('VERSIONCONTROL_CAPABILITY_CREATE_REPOSITORY',       0);
define('VERSIONCONTROL_CAPABILITY_ACCOUNT_MANAGEMENT',      1);
define('VERSIONCONTROL_CAPABILITY_DIRECTORY_RESTRICTIONS',  2);
define('VERSIONCONTROL_CAPABILITY_BRANCH_TAG_RESTRICTIONS', 3);
define('VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS',          4);
define('VERSIONCONTROL_CAPABILITY_LIST_FILES',              5);

// VCS item types.
define('VERSIONCONTROL_ITEM_FILE',       0);
define('VERSIONCONTROL_ITEM_DIRECTORY',  1);

// VCS file types.
define('VERSIONCONTROL_FILE_TEXT',       0);
define('VERSIONCONTROL_FILE_BINARY',     1);

// VCS actions for a single item (file or directory) in a commit.
define('VERSIONCONTROL_ACTION_ADDED',    0);
define('VERSIONCONTROL_ACTION_MODIFIED', 1);
define('VERSIONCONTROL_ACTION_MOVED',    2);
define('VERSIONCONTROL_ACTION_COPIED',   3);
define('VERSIONCONTROL_ACTION_MERGED',   4);
define('VERSIONCONTROL_ACTION_DELETED',  5);

/**
 * Get a list of all backends and more detailed information about each of them.
 *
 * @return
 *   A structured array containing information about all known backends.
 *   Array keys are the unique string identifier of the version control system.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'name': The user-visible name of the VCS.
 *   'description': A short description of the backend, if possible not longer
 *                  than one or two sentences.
 *   'capabilities': An array listing optional capabilities, in addition to the
 *                   required functionality like retrieval of detailed
 *                   commit information. Array values can be an arbitrary
 *                   combination of VERSIONCONTROL_CAPABILITY_* values. If no
 *                   additional capabilities are supported by the backend,
 *                   this array will be empty.
 *
 *   If no single backends can be found, an empty array is returned.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_backends() {
  static $backends;

  if (!isset($backends)) {
    $backends = module_invoke_all('versioncontrol_backends');
  }
  return $backends;
}

/**
 * Call a function from the desired VCS backend and return its result value.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 * @param $args
 *   An array of argument that will be passed to the backend function.
 *
 * @return
 *   Returns the result of the backend function. The result value of calls
 *   where the backend function has no implementation is undefined, as functions
 *   called by this function are considered mandatory for the backend.
 */
function _versioncontrol_call_backend($vcs, $function, $args) {
  return call_user_func_array('versioncontrol_'. $vcs .'_'. $function, $args);
}

/**
 * Call an optional function from the desired VCS backend and return
 * its return value, or NULL if the backend doesn't implement this function.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 * @param $args
 *   An array of argument that will be passed to the backend function.
 *
 * @return
 *   Returns the result of the backend function. The result value of calls
 *   where the backend function has no implementation is NULL.
 */
function _versioncontrol_call_backend_optional($vcs, $function, $args) {
  $full_function_name = 'versioncontrol_'. $vcs .'_'. $function;
  if (function_exists($full_function_name)) {
    return call_user_func_array($full_function_name, $args);
  }
  return NULL;
}


/**
 * Retrieve a set of repositories if they match the given constraints.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements are:
 *
 *   'vcs': An array of strings, like array('cvs', 'svn', 'git').
 *          If given, only commits for these backends will be returned.
 *   'repo_ids': An array of repository ids.
 *               If given, only the corresponding repositories will be returned.
 *
 * @return
 *   An array of repositories where the key of each element is the
 *   repository id. The corresponding value contains a structured array
 *   with the following keys:
 *
 *   'repo_id': The unique repository id.
 *   'name': The user-visible name of the repository.
 *   'vcs': The unique string identifier of the version control system
 *          that powers this repository.
 *   'root': The root directory of the repository. In most cases,
 *           this will be a local directory (e.g. '/var/repos/drupal'),
 *           but it may also be some specialized string for remote repository
 *           access. How this string may look like depends on the backend.
 *   'url_view' and 'url_diff': Not meant to be used directly, please refer
 *       to the versioncontrol_get_url_view() and versioncontrol_get_url_diff()
 *       functions if you need this functionality.
 *
 *   Additional elements may be added by specific version control system
 *   backends. If no single repository matches these constraints,
 *   an empty array is returned.
 */
versioncontrol_get_repositories($constraints = array()) {
}


/**
 * Retrieve a set of commits for the specified repository if they match
 * the given constraints.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements are:
 *
 *   'vcs': An array of strings, like array('cvs', 'svn', 'git').
 *          If given, only commits for these backends will be returned.
 *   'repo_ids': An array of repository ids. If given, only commits
 *               for the corresponding repositories will be returned.
 *   'branches': An array of strings, specified separately for each repository,
 *               like array($repo_id => array('HEAD', 'DRUPAL-5')).
 *               If given, only commits on the given branches will be returned.
 *   'tags': An array of strings, specified separately for each repository,
 *           like array($repo_id => array('DRUPAL-4-7--1-1', 'DRUPAL-5--1-3')).
 *           If given, only commits captured by these tags will be returned.
 *   'paths': An array of strings (item locations), specified separately
 *            for each repository, like
 *              array($repo_id => array(
 *                '/trunk/contributions/modules/versioncontrol',
 *                '/trunk/contributions/themes/b2',
 *              )).
 *            If given, only commits that affected this item (or its children,
 *            in case the item is a directory) will be returned.
 *   'commit_id_lower': A commit id. If given, the result set will not contain
 *                      commits earlier than this lower bound. Mind that
 *                      commit ids only correspond to chronological order
 *                      within the bounds of each repository.
 *   'commit_id_upper': A commit id. If given, the result set will not contain
 *                      commits later than this upper bound. Mind that
 *                      commit ids only correspond to chronological order
 *                      within the bounds of each repository.
 *   'date_lower': A Unix timestamp. If given, the result set will not contain
 *                 commits earlier than this lower bound.
 *   'date_upper': A Unix timestamp. If given, the result set will not contain
 *                 commits later than this upper bound.
 *   'uids': An array of Drupal user ids. If given, the result set will only
 *           contain commits that correspond to any of the specified users.
 *   'usernames': An array of system-specific usernames (the ones that the
 *                version control systems themselves get to see).
 *                Specified separately for each repository, like
 *                array($repo_id => array('dww', 'jpetso')).
 *                If given, the result set will only contain commits that
 *                correspond to any of the specified users.
 *   '[xxx]_specific': An array of VCS specific constraints. How this array
 *                     looks like is defined by the corresponding backend
 *                     module ([xxx]_backend). Other backend modules won't
 *                     get to see this constraint, so in theory you can provide
 *                     one of those for each backend in one single query.
 *
 * @return
 *   An array of commits, reversely sorted by the time of the commit.
 *   Each element contains a structured array with the following keys:
 *
 *   'commit_id': The Drupal-specific commit identifier (a simple integer)
 *                which is unique among all commits in all repositories.
 *   'repository': The repository where this commit occurred.
 *                 This is a structured array, like a single element of
 *                 what is returned by versioncontrol_get_repositories().
 *   'date': The time when the revision was committed, given as Unix timestamp.
 *   'uid': The Drupal user id of the committer.
 *   'username': The system specific VCS username of the committer.
 *   'message': The commit message.
 *   'revision': The VCS specific commit identifier, like "1.2.2.4" in CVS,
 *               "27491" in Subversion or an SHA-1 key in various distributed
 *               version control systems.
 *
 *   Additional elements may be added by specific version control system
 *   backends. If no single commit matches these constraints,
 *   an empty array is returned.
 */
versioncontrol_get_commits($constraints = array()) {
}


/**
 * Retrieve a Drupal uid / VCS username mapping given a set of user ids.
 * Non-existing uids are discarded and don't appear in the result value.
 *
 * @param $uid_list
 *   An array containing Drupal user ids.
 * @param $repositories
 *   An array of structured arrays containing repository information,
 *   presumably a subset of what is returned by versioncontrol_get_repositories().
 *   If given, only usernames of this specific repository are retrieved.
 *
 * @return
 *   A structured array that looks like
 *   array($drupal_uid => array($repo_id => 'VCS username', ...), ...).
 *   If no system specific VCS usernames correlate to the given uids,
 *   an empty array is returned.
 */
versioncontrol_get_authors_by_uid($uid_list, $repositories = NULL) {
}

/**
 * Retrieve a Drupal uid / VCS username mapping given a set of usernames.
 * Non-existing usernames are discarded and don't appear in the result value.
 *
 * @param $usernames
 *   An array containing system specific VCS usernames. Specified separately
 *   for each repository, like array($repo_id => array('dww', 'jpetso')).
 *
 * @return
 *   A structured array that looks like
 *   array($drupal_uid => array($repo_id => 'VCS username', ...), ...).
 *   If no Drupal uids correlate to the given usernames,
 *   an empty array is returned.
 */
versioncontrol_get_authors_by_username($usernames) {
}


/**
 * TODO: viewing the file for a specific branch or tag?
 * Retrieve the URL of the repository viewer that displays the given item
 * in the given repository at the time of the given commit.
 *
 * @param $repository
 *   A structured array containing repository information, like a single
 *   element of what is returned by versioncontrol_get_repositories().
 * @param $commit
 *   The point in time when the item had the name $filepath. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item for which the view URL should actually be retrieved.
 *
 * @return
 *   The item view URL corresponding to the given arguments.
 *   An empty string is returned if no item view URL has been defined.
 */
versioncontrol_get_url_view($repository, $commit, $path) {
}

/**
 * TODO: diffing the file for a specific branch or tag?
 * Retrieve the URL of the repository viewer that displays the diff of the
 * given file in the given repository, showing the diff between the given
 * commit and the commit which preceded that one.
 *
 * @param $repository
 *   A structured array containing repository information, like a single
 *   element of what versioncontrol_get_repositories() returns.
 * @param $commit
 *   The newer commit of the two that should be diffed, and the point in time
 *   when the item had the name $filepath.
 * @param $filepath
 *   The file for which the diff URL should actually be retrieved.
 *
 * @return
 *   The diff URL corresponding to the given arguments.
 *   An empty string is returned if no diff URL has been defined.
 */
versioncontrol_get_url_diff($repository, $commit, $filepath) {
}

/**
 * Retrieve the URL of the issue tracker that displays the issue/case/bug page
 * of an issue id which presumably has been mentioned in a commit message.
 * As issue tracker urls are specific to each repository, this also needs
 * to be given as argument.
 *
 * @param $repository
 *   A structured array containing repository information, like a single
 *   element of what versioncontrol_get_repositories() returns.
 * @param $issue_id
 *   A number that uniquely identifies the mentioned issue/case/bug.
 *
 * @return
 *   The issue tracker URL corresponding to the given arguments.
 *   An empty string is returned if no diff URL has been defined.
 */
versioncontrol_get_url_tracker($repository, $issue_id) {
}


/**
 * Retrieves detailed information about what happened in a single commit.
 *
 * @param $commit
 *   The commit whose actions should be retrieved.
 *
 * @return
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. Array keys are the current/new paths, also for
 *   VERSIONCONTROL_ACTION_DELETED actions even if the file actually doesn't
 *   exist anymore. The corresponding array values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'revision': The current/new (file-level) revision of the item.
 *               Given as a string, exists for all actions
 *               except VERSIONCONTROL_ACTION_DELETED.
 *   'previous revision': The (file-level) revision when this item last changed.
 *                        Given as a string, exists for all actions
 *                        except VERSIONCONTROL_ACTION_ADDED.
 *   'source path': The previous location of the item. Only exists for the
 *                  VERSIONCONTROL_ACTION_MOVED, VERSIONCONTROL_ACTION_COPIED
 *                  and VERSIONCONTROL_ACTION_MERGED actions.
 *   'source revision': Only exists for the VERSIONCONTROL_ACTION_MERGED action,
 *                      and specifies the last (file-level) revision of the
 *                      file that was merged into the current/new path.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
versioncontrol_get_commit_actions($commit) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_commit_actions', array($commit)
  );
}

/**
 * Retrieve the branches that have been affected by the given commit.
 *
 * @return
 *   An array of strings that identify a branch in the respective repository,
 *   like for example array('DRUPAL-5') or array('trunk', '5.x').
 */
versioncontrol_get_commit_branches($commit) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_commit_branches', array($commit)
  );
}

/**
 * Retrieve all branches that exist for the given item $path, and how this item
 * is named there.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose branches should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $branch1_name => $branch1_path,
 *       $branch2_name => $branch2_path,
 *       ...
 *     ).
 *   An empty array is returned if there are no branches for this item.
 *   NULL is returned if the given path is not under version control,
 *   or was not under version control at the time of $commit.
 */
versioncontrol_get_item_branches($commit, $path) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_item_branches', array($commit, $path)
  );
}

/**
 * Retrieve all tags that exist for the given item $path, and how this item
 * is named there.
 *
 * If the given path is not under version control (or was not under revision
 * control at the time of $commit), NULL is returned.
 * An empty array is returned if there are no tags for this item.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose tags should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $tag1_name => $tag1_path,
 *       $tag2_name => $tag2_path,
 *       ...
 *     ).
 *   An empty array is returned if there are no tags for this item.
 *   NULL is returned if the given path is not under version control,
 *   or was not under version control at the time of $commit.
 */
versioncontrol_get_item_tags($commit, $path) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_item_tags', array($commit, $path)
  );
}

/**
 * TODO: items for only one branch?
 * Retrieve the set of files and directories that exist at a specified revision
 * in the given path inside the repository.
 *
 * @param $commit
 *   The state of the repository for retrieving the items.
 * @param $path
 *   The item which holds the desired items that are to be listed.
 *   If $path is a file, the returned array only holds one single element.
 *   If $path is a directory, the returned array holds the element for $path
 *   itself, plus its child elements.
 * @param $recursive
 *   If FALSE, only the direct children of $path will be retrieved.
 *   If TRUE, you'll get every single descendant of $path.
 *
 * @return
 *   A structured array containing the exact details of which items exist(ed)
 *   at the time of the commit. Array keys are the current/new paths.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'revision': The (file-level) revision when the item was last changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
versioncontrol_get_items($commit, $path, $recursive = FALSE) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_items',
    array($commit, $path, $recursive)
  );
}

/**
 * TODO: item history for only one branch?
 * Retrieve the revisions where the given item $path has been changed, in
 * reverse chronological order.
 *
 * If the given path is not under version control (or was not under version
 * control at the time of $commit), NULL is returned.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose history should be retrieved.
 *
 * @return
 *   An array containing the exact details of all item changes. Each element
 *   of the array is a structured array consisting of elements with the
 *   following keys:
 *
 *   'path': The path of the item name at the specific revision.
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'revision': The current/new (file-level) revision of the item.
 *               Given as a string, exists for all actions
 *               except VERSIONCONTROL_ACTION_DELETED.
 *   'previous revision': The (file-level) revision when this item last changed.
 *                        Given as a string, exists for all actions
 *                        except VERSIONCONTROL_ACTION_ADDED.
 *   'source path': The previous location of the item. Only exists for the
 *                  VERSIONCONTROL_ACTION_MOVED, VERSIONCONTROL_ACTION_COPIED
 *                  and VERSIONCONTROL_ACTION_MERGED actions.
 *   'source revision': Only exists for the VERSIONCONTROL_ACTION_MERGED action,
 *                      and specifies the last (file-level) revision of the
 *                      file that was merged into the current/new path.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
versioncontrol_get_item_history($commit, $path) {
  return _versioncontrol_call_backend(
    $commit['repository']['vcs'], 'get_item_history', array($commit, $path)
  );
}


/**
 * TODO: contents of the file for a specific branch or tag?
 * Retrieve the text or binary data of the given file in the specified commit.
 *
 * This function is optional for VCS backends to implement; if a backend
 * doesn't implement this function, its return value will be NULL.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose history should be retrieved.
 *
 * @return
 *   A structured array containing the type and contents of the desired file
 *   at the time of the commit, consisting of elements with the following keys:
 *
 *   'type': Specifies the file type, which is either
 *           VERSIONCONTROL_FILE_TEXT or VERSIONCONTROL_FILE_BINARY.
 *   'contents': The raw contents of the file.
 *
 *   NULL is returned if the given path is not under version control,
 *   or was not under version control at the time of $commit, or if the
 *   specific backend module does not implement retrieving file contents.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
versioncontrol_get_file_contents($commit, $path) {
  return _versioncontrol_call_backend_optional(
    $commit['repository']['vcs'], 'get_file_contents', array($commit, $path)
  );
}

/**
 * TODO: annotation of the file for a specific branch or tag?
 * Retrieve an array where each element represents a single line of the
 * given file in the specified commit, annotated with the committer who last
 * modified that line.
 *
 * This function is optional for VCS backends to implement; if a backend
 * doesn't implement this function, its return value will be NULL.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose history should be retrieved.
 *
 * @return
 *   A structured array that consists of one element per line, with
 *   line numbers as keys (starting from 1) and a structured array as values,
 *   where each of them consists of elements with the following keys:
 *
 *   'username': The system specific VCS username of the last committer.
 *   'line': The contents of the line, without linebreak characters.
 *
 *   NULL is returned if the given path is not under version control,
 *   or was not under version control at the time of $commit, or if it is
 *   marked as binary file, or if the specific backend module does not
 *   implement annotations.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
versioncontrol_get_file_annotation($commit, $path) {
  return _versioncontrol_call_backend_optional(
    $commit['repository']['vcs'], 'get_file_annotation', array($commit, $path)
  );
}


/**
 * Call a function from the desired VCS backend and return its result value.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 * @param $args
 *   An array of argument that will be passed to the backend function.
 *
 * @return
 *   Returns the result of the backend function. The result value of calls
 *   where the backend function has no implementation is undefined, as functions
 *   called by this function are considered mandatory for the backend.
 */
function _versioncontrol_call_backend($vcs, $function, $args) {
  return call_user_func_array('versioncontrol_'. $vcs .'_'. $function, $args);
}

/**
 * Call an optional function from the desired VCS backend and return
 * its return value, or NULL if the backend doesn't implement this function.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 * @param $args
 *   An array of argument that will be passed to the backend function.
 *
 * @return
 *   Returns the result of the backend function. The result value of calls
 *   where the backend function has no implementation is NULL.
 */
function _versioncontrol_call_backend_optional($vcs, $function, $args) {
  $full_function_name = 'versioncontrol_'. $vcs .'_'. $function;
  if (function_exists($full_function_name)) {
    return call_user_func_array($full_function_name, $args);
  }
  return NULL;
}
