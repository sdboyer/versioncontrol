<?php
// $Id$
/**
 * @file
 * FakeVCS backend -
 * An example module illustrating how to write a VCS backend.
 *
 * Copyright 2007 by Jakob Petsovits <jpetso@gmx.at>
 *
 * Distributed under the GNU General Public Licence version 2 or higher,
 * as published by the FSF on http://www.gnu.org/copyleft/gpl.html
 */

/**
 * Implementation of hook_versioncontrol_backends().
 */
fakevcs_backend_versioncontrol_backends() {
  // Our example VCS is called FakeVCS, and supports all possible capabilities.

  return array(
    // The array key is up to 8 characters long, and used as unique identifier
    // for this VCS, in functions, URLs and in the database.
    'fakevcs' => array(
      // The user-visible name of the VCS.
      'name' => 'FakeVCS',

      // A short description of the backend, if possible not longer than one or two sentences.
      'description' => t('FakeVCS is a version control system that is '.
                         'specifically capable in doing everything that any '.
                         'other version control system might ever do.'),

      // The prefix for function names that are used for this VCS's backend function calls.
      // I think we might not need this and call xxx_backend for the 'xxx' backend instead?
      // TODO: Look into how fago accomplished this in pageroute.
      // 'prefix' => 'fakevcs_backend',

      // A list of optional capabilities, in addition to the required retrieval
      // of detailed commit information. All allowed values are listed below.
      'capabilities' => array(
        // Able to programmatically create a new repository at a specified
        // location in the file system.
        VERSIONCONTROL_CAPABILITY_CREATE_REPOSITORY,

        // Able to programmatically create and delete user accounts for the
        // specific VCS, and assign or deny them access permission for certain
        // directories in a repository.
        VERSIONCONTROL_CAPABILITY_ACCOUNT_MANAGEMENT,

        // Able to cancel commits if the committer lacks permissions to commit
        // to specific directories.
        VERSIONCONTROL_CAPABILITY_DIRECTORY_RESTRICTIONS,

        // Able to cancel commits if the committer lacks permissions to commit
        // to specific branches or tags.
        VERSIONCONTROL_CAPABILITY_BRANCH_TAG_RESTRICTIONS,

        // Able to retrieve a file or its revision number based on a global
        // revision identifier.
        VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS,

        // Able to get the list of all current files and directories in a given
        // version controlled directory, along with revision identifiers for
        // each of the files. Comes in handy for repository browsing.
        VERSIONCONTROL_CAPABILITY_LIST_FILES,
      );
    ),

    // More backend entries are possible - most modules won't need this,
    // but let's still provide the opportunity to do so, for consistency
    // with similar hooks from other modules and easier merging of the arrays.
  );
}

/**
 * Implementation of [vcs_backend]_repository_additions():
 * Return an array of FakeVCS specific repository information. In the finished
 * commit, this array will be accessible as $repository['fakevcs_specific'].
 * If no additions are necessary, this function returns NULL.
 */
fakevcs_backend_repository_additions($repository) {
  return array(
    'modules' => array('drupal', 'contributions');
  );
}

/**
 * Implementation of [vcs_backend]_filter_commits():
 * Unset commits that don't match any of the given constraints.
 *
 * @param $commits
 *   The original array of commits retrieved by versioncontrol_get_commits().
 *   The filtered version will naturally be a subset of those.
 * @param $branches
 *   An array of strings, specified separately for each repository,
 *   like array($repo_id => array('HEAD', 'DRUPAL-5')).
 *   If given, only commits on the given branches will be returned.
 * @param $tags
 *   An array of strings, specified separately for each repository,
 *   like array($repo_id => array('DRUPAL-4-7--1-1', 'DRUPAL-5--1-3')).
 *   If given, only commits captured by these tags will be returned.
 * @param paths
 *   An array of strings (item locations), specified separately for
 *   each repository, like
 *     array($repo_id => array(
 *       '/trunk/contributions/modules/versioncontrol',
 *       '/trunk/contributions/themes/b2',
 *     )).
 *   If given, only commits that affected this item (or its children,
 *   in case the item is a directory) will be returned.
 * @param $fakevcs_specific
 *   An array of FakeVCS specific constraints. Say, if FakeVCS supported
 *   modules like the CVS ones, the array would contain a 'modules' element
 *   for filtering by module.
 */
fakevcs_backend_filter_commits(&$commits, $branches = NULL, $tags = NULL, $paths = NULL, $fakevcs_specific = NULL) {
  foreach($commits as $key => $commit) {
    if ($constraint == 'matched') {
      continue;
    }
    else if ($other_constraint == 'matched') {
      continue;
    }
    else {
      unset($commits[$key]);
    }
  }
}

/**
 * Implementation of [vcs_backend]_commit_additions():
 * Return an array of FakeVCS specific commit information. In the finished
 * commit, this array will be accessible as $commit['fakevcs_specific'].
 * If no additions are necessary, this function returns NULL.
 */
fakevcs_backend_commit_additions($commit) {
  return array(
    'module' => 'contributions';
  );
}


/**
 * Implementation of [vcs_backend]_get_authors_by_uid():
 * Retrieve a Drupal uid / VCS username mapping given a set of user ids.
 * Non-existing uids are discarded and don't appear in the result value.
 *
 * @param $uid_list
 *   An array containing Drupal user ids.
 * @param $repositories
 *   An array of structured arrays containing repository information,
 *   presumably a subset of what is returned by versioncontrol_get_repositories().
 *   If given, only usernames of this specific repository are retrieved.
 *
 * @return
 *   A structured array that looks like
 *   array($drupal_uid => array($repo_id => 'VCS username', ...), ...).
 *   If no system specific VCS usernames correlate to the given uids,
 *   an empty array is returned.
 */
fakevcs_backend_get_authors_by_uid($uid_list, $repositories = NULL) {
  // Let's say $uid_list == array(1, 56020, -328) and $repositories == NULL:
  return array(
    1 => array(
      $core_repo    => 'dries',
      $contrib_repo => 'dries',
    ),
    56020 => array(
      $contrib_repo => 'jpetso',
    ),
  );
}

/**
 * Implementation of [vcs_backend]_get_authors_by_username():
 * Retrieve a Drupal uid / VCS username mapping given a set of usernames.
 * Non-existing usernames are discarded and don't appear in the result value.
 *
 * @param $usernames
 *   An array containing system specific VCS usernames. Specified separately
 *   for each repository, like array($repo_id => array('dww', 'jpetso')).
 *
 * @return
 *   A structured array that looks like
 *   array($drupal_uid => array($repo_id => 'VCS username', ...), ...).
 *   If no Drupal uids correlate to the given usernames,
 *   an empty array is returned.
 */
fakevcs_backend_get_authors_by_username($usernames) {
  // Let's say $usernames == array(
  //   $core_repo => array('dries', 'jpetso', 'doesntexist'),
  //   $contrib_repo => array('dries', 'jpetso', 'doesntexist'),
  // ):
  return array(
    1 => array(
      $core_repo    => 'dries',
      $contrib_repo => 'dries',
    ),
    56020 => array(
      $contrib_repo => 'jpetso',
    ),
  );
}


/**
 * Implementation of [vcs_backend]_get_commit_actions():
 * Retrieves detailed information about what happened in a single commit.
 *
 * @param $commit
 *   The commit whose actions should be retrieved.
 *
 * @return
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. Array keys are the current/new paths, also for
 *   VERSIONCONTROL_ACTION_DELETED actions even if the file actually doesn't
 *   exist anymore. The corresponding array values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'revision': The current/new (file-level) revision of the item.
 *               Given as a string, exists for all actions
 *               except VERSIONCONTROL_ACTION_DELETED.
 *   'previous revision': The (file-level) revision when this item last changed.
 *                        Given as a string, exists for all actions
 *                        except VERSIONCONTROL_ACTION_ADDED.
 *   'source path': The previous location of the item. Only exists for the
 *                  VERSIONCONTROL_ACTION_MOVED, VERSIONCONTROL_ACTION_COPIED
 *                  and VERSIONCONTROL_ACTION_MERGED actions.
 *   'source revision': Only exists for the VERSIONCONTROL_ACTION_MERGED action,
 *                      and specifies the last (file-level) revision of the
 *                      file that was merged into the current/new path.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 */
fakevcs_backend_get_commit_actions($commit) {
  // Assuming $commit is a single commit array that looks like this:
  $commit = array(
    // The commit id, a simple running number. Doesn't have any specific
    // meaning, but is necessary for indexing and joining tables.
    'commit_id' => 2345,
    // The repository that was affected by this commit.
    'repository' => $affected_repository,
    // The time when the commit was executed, in Unix timestamp format.
    'date' => time(),
    // User id of the committer's Drupal user account.
    // 0 if no corresponding account exists.
    'uid' => $user->uid,
    // The committer's username known to the repository itself. In most cases
    // this will probably be the name of the committer's Unix user account.
    'username' => 'jpetso',
    // The commit message, which is expected to span one or more lines.
    'message' => 'All kinds of demonstrative changes.',
    // The revision identifier of the commit, in the VCS's proprietary format -
    // running number, SHA-1 hash, or whatever. If there is no single revision
    // identifier for the whole commit (which should only be the case for CVS)
    // then the value for this key is set to NULL.
    'revision' => '404', // for this commit, let's assume this is an SVN repository
  );

  return array(
    // VERSIONCONTROL_ACTION_ADDED action:
    // contains 'type', 'action' and 'revision'
    '/trunk/contributions/modules/versioncontrol/versioncontrol.module' => array(
      'type'     => VERSIONCONTROL_ITEM_FILE,
      'action'   => VERSIONCONTROL_ACTION_ADDED,
      'revision' => '404',
    ),
    // VERSIONCONTROL_ACTION_MODIFIED action:
    // contains 'type', 'action', 'revision' and 'previous revision'
    '/trunk/contributions/modules/versioncontrol/versioncontrol.install' => array(
      'type'              => VERSIONCONTROL_ITEM_FILE,
      'action'            => VERSIONCONTROL_ACTION_MODIFIED,
      'revision'          => '404',
      'previous revision' => '354',
    ),
    // VERSIONCONTROL_ACTION_DELETED action:
    // contains 'type', 'action' and 'previous revision'
    '/branches/sandbox/jpetso/versioncontrol-notes.txt' => array(
      'type'              => VERSIONCONTROL_ITEM_FILE,
      'action'            => VERSIONCONTROL_ACTION_DELETED,
      'previous revision' => '41',
    ),
    // VERSIONCONTROL_ACTION_MOVED action: contains 'type', 'action',
    // 'revision', 'previous revision', 'source path' and 'modified'
    // (if the file was also modified in addition to being moved)
    '/trunk/contributions/modules/versioncontrol/versioncontrol.info' => array(
      'type'              => VERSIONCONTROL_ITEM_FILE,
      'action'            => VERSIONCONTROL_ACTION_MOVED,
      'modified'          => TRUE,
      'revision'          => '404',
      'previous revision' => '41',
      'source path'       => '/branches/sandbox/jpetso/versioncontrol.info',
    ),
    // VERSIONCONTROL_ACTION_COPIED action: contains 'type', 'action',
    // 'revision', 'previous revision', 'source path' and 'modified'
    '/trunk/contributions/modules/versioncontrol/README.txt' => array(
      'type'              => VERSIONCONTROL_ITEM_FILE,
      'action'            => VERSIONCONTROL_ACTION_COPIED,
      'modified'          => FALSE,
      'revision'          => '404',
      'previous revision' => '220',
      'source path'       => '/branches/sandbox/jpetso/README-template.txt',
    ),
    // VERSIONCONTROL_ACTION_MERGED action: 
    // contains 'type', 'action', 'revision', 'previous revision',
    // 'source path' and 'source revision'
    '/trunk/contributions/modules/versioncontrol/fakevcs_backend/fakevcs_backend.module' => array(
      'type'              => VERSIONCONTROL_ITEM_FILE,
      'action'            => VERSIONCONTROL_ACTION_MERGED,
      'revision'          => '404',
      'previous revision' => '403',
      'source path'       => '/branches/work/versioncontrol-improve-data-structures/data-structures.php',
      'source revision'   => '198',
    ),
    // VERSIONCONTROL_ITEM_DIRECTORY type actions can occur with 'action' being
    // one of VERSIONCONTROL_ACTION_MOVED, VERSIONCONTROL_ACTION_COPIED
    // and VERSIONCONTROL_ACTION_DELETED.
    // Other than that, same style as VERSIONCONTROL_ITEM_FILE actions.
    '/tags/5.x-1.1/contributions/modules/cvslog' => array(
      'type'              => VERSIONCONTROL_ITEM_DIRECTORY,
      'action'            => VERSIONCONTROL_ACTION_COPIED,
      'revision'          => '404',
      'previous revision' => '397',
      'source path'       => '/trunk/contributions/modules/cvslog',
    ),
    '/trunk/contributions/modules/versioncontrol/fakevcs_backend' => array(
      'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
      'action'   => VERSIONCONTROL_ACTION_ADDED,
      'revision' => '404',
    ),
  );
}

/**
 * Implementation of [vcs_backend]_get_commit_items():
 * Retrieve the set of files and directories that exist at a specified revision
 * in the given path inside the repository.
 *
 * @param $commit
 *   The commit whose items should be retrieved.
 * @param $path
 *   The item which holds the desired items that are to be listed.
 *   If $path is a file, the returned array only holds one single element.
 *   If $path is a directory, the returned array holds the element for $path
 *   itself, plus its child elements.
 * @param $recursive
 *   If FALSE, only the direct children of $path will be retrieved.
 *   If TRUE, you'll get every single descendant of $path.
 *
 * @return
 *   A structured array containing the exact details of which items exist(ed)
 *   at the time of the commit. Array keys are the current/new paths.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'revision': The (file-level) revision when the item was last changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 */
fakevcs_backend_get_commit_items($commit, $path, $recursive = FALSE) {
  // Assuming $commit is a single commit array that looks like this:
  $commit = array(
    // The plain, given part looks just like in _get_commit_actions(),
    // you can look up the descriptions there.
    'commit_id' => 3456,
    'repository' => $affected_repository,
    'date' => time() + 23,
    'uid' => $user->uid,
    'username' => 'jpetso',
    'message' => 'Diabolic commit to anywhere else, but not the versioncontrol module.',
    'revision' => '666', // for this commit, let's assume this is an SVN repository
  );
  // ...and $path == '/trunk/contributions/modules/versioncontrol'.

  return array(
    '/trunk/contributions/modules/versioncontrol' => array( // == rtrim($path, '/')
      'type'      => VERSIONCONTROL_ITEM_DIRECTORY,
      'revision'  => '502',
    ),
    '/trunk/contributions/modules/versioncontrol/versioncontrol.module' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '502',
    ),
    '/trunk/contributions/modules/versioncontrol/versioncontrol.info' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '404',
    ),
    '/trunk/contributions/modules/versioncontrol/versioncontrol.install' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '404',
    ),
    '/trunk/contributions/modules/versioncontrol/README.txt' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '404',
    ),
    '/trunk/contributions/modules/versioncontrol/fakevcs_backend' => array(
      'type'      => VERSIONCONTROL_ITEM_DIRECTORY,
      'revision'  => '497',
    ),
  );

  // Or the same thing in CVS - note the 'revision' elements.
  // CVS doesn't do repository-wide revisions, so in addition to the branch
  // or tag, the CVS backend would use the 'date' value instead of 'revision'
  // to determine the then-current file list. Or the commit id if all of
  // the querying is done from the database.
  $commit['revision'] = NULL;

  return array(
    '/contributions/modules/versioncontrol' => array( // == rtrim($path, '/')
      'type'      => VERSIONCONTROL_ITEM_DIRECTORY,
      'revision'  => NULL, // CVS doesn't track directory-level revisions
    ),
    '/contributions/modules/versioncontrol/versioncontrol.module' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '1.2.2.13',
    ),
    '/contributions/modules/versioncontrol/versioncontrol.info' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '1.1',
    ),
    '/contributions/modules/versioncontrol/versioncontrol.install' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '1.2.2.5',
    ),
    '/contributions/modules/versioncontrol/README.txt' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '1.2.2.5',
    ),
    '/contributions/modules/versioncontrol/fakevcs_backend' => array(
      'type'      => VERSIONCONTROL_ITEM_DIRECTORY,
      'revision'  => NULL,
    ),
  );

  // If $path is a file, say, '/trunk/contributions/modules/versioncontrol/versioncontrol.module',
  // then you return just this one entry.
  return array(
    '/contributions/modules/versioncontrol/versioncontrol.module' => array(
      'type'      => VERSIONCONTROL_ITEM_FILE,
      'revision'  => '1.2.2.13',
    ),
  );
}

/**
 * Implementation of [vcs_backend]_get_commit_branches():
 * Retrieve the branches that have been affected by the given commit.
 *
 * @return
 *   An array of strings that identify a branch in the respective repository.
 */
fakevcs_backend_get_commit_branches($commit) {
  // How CVS would probably do it
  return array('DRUPAL-5');
  // How SVN could also do it
  return array('trunk', '5.x');
}

/**
 * Implementation of [vcs_backend]_get_item_branches():
 * Retrieve all branches that exist for the given item $path, and how this item
 * is named there.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose branches should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $branch1_name => $branch1_path,
 *       $branch2_name => $branch2_path,
 *       ...
 *     ).
 *   An empty array is returned if there are no branches for this item.
 *   NULL is returned if the given path is not under version control,
 *   or was not under version control at the time of $commit.
 */
fakevcs_backend_get_item_branches($commit, $path) {
  // How CVS would probably do it
  return array(
    'HEAD' => $path,
    'DRUPAL-5' => $path,
  );
  // How SVN could also do it,
  // if for example $path == '/trunk/contributions/modules/versioncontrol':
  return array(
    'trunk' => '/trunk/contributions/modules/versioncontrol',
    '5.x' => '/branches/5.x/contributions/modules/versioncontrol',
  );
}

/**
 * Implementation of [vcs_backend]_get_item_tags():
 * Retrieve all tags that exist for the given item $path, and how this item
 * is named there.
 *
 * If the given path is not under version control (or was not under version
 * control at the time of $commit), NULL is returned.
 * An empty array is returned if there are no tags for this item.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose tags should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $tag1_name => $tag1_path,
 *       $tag2_name => $tag2_path,
 *       ...
 *     ).
 *   An empty array is returned if there are no tags for this item.
 *   NULL is returned if the given path is not under version control,
 *   or was not under version control at the time of $commit.
 */
fakevcs_backend_get_item_tags($commit, $path) {
  // How CVS would probably do it
  return array(
    'DRUPAL-5--1-1' => $path,
    'DRUPAL-5--1-2' => $path,
  );
  // How SVN could also do it,
  // if for example $path == '/trunk/contributions/modules/versioncontrol':
  return array(
    '5.x-1.1' => '/tags/5.x-1.1/contributions/modules/versioncontrol',
    '5.x-1.2' => '/tags/5.x-1.2/contributions/modules/versioncontrol',
  );
}

/**
 * TODO: item history for only one branch?
 * Implementation of [vcs_backend]_get_item_history():
 * Retrieve the revisions where the given item $path has been changed, in
 * reverse chronological order.
 *
 * If the given path is not under version control (or was not under version
 * control at the time of $commit), NULL is returned.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose history should be retrieved.
 *
 * @return
 *   An array containing the exact details of all item changes. Each element
 *   of the array is a structured array consisting of elements with the
 *   following keys:
 *
 *   'path': The path of the item name at the specific revision.
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'revision': The current/new (file-level) revision of the item.
 *               Given as a string, exists for all actions
 *               except VERSIONCONTROL_ACTION_DELETED.
 *   'previous revision': The (file-level) revision when this item last changed.
 *                        Given as a string, exists for all actions
 *                        except VERSIONCONTROL_ACTION_ADDED.
 *   'source path': The previous location of the item. Only exists for the
 *                  VERSIONCONTROL_ACTION_MOVED, VERSIONCONTROL_ACTION_COPIED
 *                  and VERSIONCONTROL_ACTION_MERGED actions.
 *   'source revision': Only exists for the VERSIONCONTROL_ACTION_MERGED action,
 *                      and specifies the last (file-level) revision of the
 *                      file that was merged into the current/new path.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 */
fakevcs_backend_get_item_history($commit, $path) {
  // Assuming $commit is a single commit array that looks like this:
  $commit = array(
    // The plain, given part looks just like in _get_commit_actions(),
    // you can look up the descriptions there.
    'commit_id' => 3456,
    'repository' => $affected_repository,
    'date' => time() + 23,
    'uid' => $user->uid,
    'username' => 'jpetso',
    'message' => 'Diabolic commit to anywhere else, but not the versioncontrol module.',
    'revision' => '666', // for this commit, let's assume this is an SVN repository
  );
  // ...and $path == '/trunk/contributions/modules/versioncontrol/versioncontrol.info'.

  return array(
    array(
      'path'              => '/trunk/contributions/modules/versioncontrol/versioncontrol.info',
      'action'            => VERSIONCONTROL_ACTION_MOVED,
      'revision'          => '404',
      'previous revision' => '41',
      'source path'       => '/branches/sandbox/jpetso/versioncontrol.info',
    ),
    array(
      'path'     => '/branches/sandbox/jpetso/versioncontrol.info',
      'action'   => VERSIONCONTROL_ACTION_ADDED,
      'revision' => '41',
    ),
  );
}

/**
 * TODO: contents of the file for a specific branch or tag?
 * Implementation of [vcs_backend]_get_file_contents():
 * Retrieve the text or binary data of the given file in the specified commit.
 *
 * This function is optional for VCS backends to implement; if a backend
 * doesn't implement this function, its return value will be NULL.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose history should be retrieved.
 *
 * @return
 *   A structured array containing the type and contents of the desired file
 *   at the time of the commit, consisting of elements with the following keys:
 *
 *   'type': Specifies the file type, which is either
 *           VERSIONCONTROL_FILE_TEXT or VERSIONCONTROL_FILE_BINARY.
 *   'contents': The raw contents of the file.
 */
fakevcs_backend_get_file_contents($commit, $path) {
  // In case the file is marked as text file:
  return array(
    'type'     => VERSIONCONTROL_FILE_TEXT,
    'contents' => $file_contents,
  );
  // In case the file is marked as binary file:
  return array(
    'type'     => VERSIONCONTROL_FILE_BINARY,
    'contents' => $file_contents,
  );
}

/**
 * TODO: annotation of the file for a specific branch or tag?
 * Implementation of [vcs_backend]_get_file_annotation():
 * Retrieve an array where each element represents a single line of the
 * given file in the specified commit, annotated with the committer who last
 * modified that line.
 *
 * This function is optional for VCS backends to implement; if a backend
 * doesn't implement this function, its return value will be NULL.
 *
 * If the given path is not under version control (or was not under revision
 * control at the time of $commit) or the file is marked as binary,
 * NULL is returned.
 *
 * @param $commit
 *   The point in time when the item had the name $path. Remember, renaming
 *   operations can pretty much screw up unique item identification otherwise.
 * @param $path
 *   The item whose history should be retrieved.
 *
 * @return
 *   A structured array that consists of one element per line, with
 *   line numbers as keys (starting from 1) and a structured array as values,
 *   where each of them consists of elements with the following keys:
 *
 *   'username': The system specific VCS username of the last committer.
 *   'line': The contents of the line, without linebreak characters.
 *
 *   NULL is returned if the given file is not under revision control,
 *   or was not under version control at the time of $commit,
 *   or if it is marked as binary file.
 */
fakevcs_backend_get_file_annotation($commit, $path) {
  // In case the file is marked as text file:
  return array(
    1 => array(
      'username' => 'dries',
      'line'     => '<?php',
    ),
    2 => array(
      'username' => 'jpetso',
      'line'     => '// $Id$',
    ),
  );
}
